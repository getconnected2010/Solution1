C# text
//importing namespaces to access the classes within
using nameSpaceName;
using System.Collections;
using System.Collections.Generic;
using System.Threading; //for Thread.sleep(1000)


##concepts
Stack and Heap =>
- stack and heap are memory allocations in RAM for program.
- they store variables and objects as long as they are within scope i.e. {...}
- primitive types and pointers to objects in memory are stored in Stack.
  - stack is like a bucket and gets filled with variables one on top of the other.
  - stack works as last in first out LIFO
- Objects are strored in Heap.

- once the variables and obj are out of scope, they are deleted and momory given back to OS.
  - stack deletes starting from top LIFO all variables and pointers out of scope.
  - garbage collector deletes all objects in heap that don't have pointers in stack.
    - no pointers in heap means pointers in stack are deleted when out of scope.
    - garbage collector has its own random timing to clear the heap but stack immediate.

Value types and reference types
- primitives are passed by value hence value types. int x=3; int y=x;
- custom types such as objects are passed by ref hence reference types. 
    - Student x = new Student(); x = y; ...y will reference same obj

Boxing and unboxing
- Boxing - assigning a value type of variable to a reference type of variable.
  - converting stack to heap. int x = 0; object y=x; primitive to object.
- Unboxing - assigning a reference type variable to a value type of variable.
  - converting heap to stack. object y; int x = (int)y; object to primitive.
- bosing and unboxing is CPU intensive task. Avoid.

Collections
- Arrays are strongly typed so there is no boxing and unboxing.
  - They are good for large amount of data because they operate fast
- ArrayList are not typed. Can store all types. Each is stored as heap.
  - Boxing and unboxing happens for each element thus slow for large data.
  - using System.Collections;
- Generic list are typed. They are flexible like arrayList but fast like array.
  - No boxing and unboxing.
  - List<int> genListArr = new List<int>();
  - using System.Collections.Generic;

#VS functionalities
//monitor a variable or change on runtime
right click => add watch
//memory address location of variables
in add watch, place amber sign next to variable name &x


//casting a double db to an int counter;
counter = (int) db;
//primitives are passed by value. custom types such as objects are passed by ref.
int i= 9;
int y= i; passed by value
MyClass x = new MyClass();
x.someProperty = 3;
x = z;  passed by reference. x and z are pointers to same object in heap
z.someProperty = 4;   this will change original value.
//convert a string a to an int counter
counter = Convert.ToInt32(a);
//current time
return DateTime.Now.ToString();
//write to the console
Console.WriteLine("eden");
//read from the console
String input = Console.ReadLine();
Console.WriteLine("your input "+ input);
//struct. These are value types. Not reference type like class.
    public struct myStruct
    {
        public int a;
        int b;
        public void hi()
        {
            Console.WriteLine("hello in struct");
        }
    }
    //access it by creating an instance
    myStruct abc = new myStruct();
    abc.a = 2;
    abc.hi();

//arrays (strongly typed, no boxing and unboxing, fast operation)
//using System.Collections;
int[] arrInt = new int[13];
string[] arrStr = new string[2];
arrInt[0] = 4;
arrStr[0] = "eden";

//arraylists (not typed, boxing and unboxing, slow performance)
//using System.Collections;
ArrayList arrList = new ArrayList();
arrList.Add(2);
arrList.Add("eden");

//generic list (typed, no boxing and unboxing, fast performance)
//using System.Collections.Generic;
List<int> genIntList = new List<int>();
genIntList.Add(1);
genIntList.Add(5);

List<string> genStrList = new List<string>();
genStrList.Add("eden");
genStrList.Add("daddy");

//for loop
for(int i=0; i<10; i++)
{
     Console.WriteLine(i);
}
//foreach loop
foreach(string item in genStrList)
{
    Thread.sleep(1000);  //pauses for 1sex every iteration
    Console.WriteLine(item);
}

//try catch block for exception. throw will display the error.
try
{
    int result = num1 / num2;
}
    catch (Exception e)
{
    Console.WriteLine(e);           
    throw;
}

//sleep function takes miliseconds. import using System.Threading; at the top
Thread.sleep(1000);


















